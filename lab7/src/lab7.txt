№1 
***  !!! TCP/IP - Набор интернет-протоколов — это концептуальная модель и набор коммуникационных протоколов, используемых в Интернете и подобных компьютерных сетях. Базовые протоколы в пакете — это протокол управления передачей (TCP) и интернет-протокол (IP)
Набор интернет-протоколов обеспечивает сквозную передачу данных, определяющую, как данные должны пакетироваться, обрабатываться, передаваться, маршрутизироваться и приниматься. 
Эта функциональность организована в четыре слоя абстракции, которые классифицируют все связанные протоколы в соответствии с объемом задействованных сетей. От самого низкого до самого высокого уровня — это уровень связи, содержащий методы связи для данных, которые остаются в пределах одного сегмента сети; интернет-уровень, обеспечивающий межсетевое взаимодействие между независимыми сетями; транспортный уровень, обрабатывающий связь между хостами; и прикладной уровень, который обеспечивает обмен данными между процессами для приложений.

!!! Механизм TCP предоставляет поток данных с предварительной установкой соединения, осуществляет повторный запрос данных в случае потери данных и устраняет дублирование при получении двух копий одного пакета, гарантируя тем самым (в отличие от UDP) целостность передаваемых данных и уведомление отправителя о результатах передачи.
Когда осуществляется передача от компьютера к компьютеру через Интернет, TCP работает на верхнем уровне между двумя конечными системами, например, браузером и веб-сервером. TCP осуществляет надёжную передачу потока байтов от одного процесса к другому. TCP реализует управление потоком, управление перегрузкой, рукопожатие, надёжную передачу. SYN, SYN ACK, ACK
(низкая скорость) (отправка фото, переписка, транзакции банк)

!!! IP - маршрутизируемый протокол сетевого уровня стека TCP/IP. IP объединяет сегменты сети в единую сеть, обеспечивая доставку пакетов данных между любыми узлами сети через произвольное число промежуточных узлов (маршрутизаторов). 
https://www.ibm.com/docs/ru/aix/7.2?topic=protocol-tcpip-protocols

!!! UDP - транспортный протокол, без предварительного соединения и переспрашивания данных. Быстро, но не надежно (передача потокового видео, общения в голосовом формате).

!!! Socket создает конечную точку соединения и возвращает ее описатель.
SOCK_STREAM Обеспечивает создание двусторонних надежных и последовательных потоков байтов , поддерживающих соединения. Может также поддерживаться механизм
внепоточных данных.
SOCK_DGRAM - Поддерживает датаграммы (ненадежные сообщения с ограниченной длиной и не поддерживающие соединения).
(В случае ошибки возвращается -1; в противном случае возвращается описатель, ссылающийся на сокет.)

!!! bind(в коде серверов) - привязать имя (локальный адрес my_addr длиной addrlen) к сокету, Традиционно, эта операция называется lqприсваивание сокету имени.rq Когда сокет только что создан с помощью socket(2), он существует в пространстве имён (семействе адресов), но не имеет назначенного имени.
(В случае успеха возвращается ноль. При ошибке возвращается -1,)

!!! listen (в коде клиента) (для TCP) Для того, чтобы принимать соединения, сначала нужно создать сокет с помощью socket(2), затем выразить готовность принимать входящие соединения и задать размер очереди с помощью listen, а затем вызывать accept(2) по мере появления новых соединений. 
Системный вызов listen применим только к сокетам типа SOCK_STREAM или SOCK_SEQPACKET.
Параметр backlog задает максимальную длину, до которой может расти очередь ожидающих соединений. Если приходит запрос на соединение, а очередь полна, то клиент получит ошибку ECONNREFUSED или, если соответствующие протокол поддерживает повторную передачу, запрос может быть игнорирован, 
чтобы попытаться ответить на повторный запрос.
(В случае успеха возвращается ноль. При ошибке возвращается -1, а errno устанавливается должным образом)

!!! Функция accept (для TCP) (принять соединение на сокете) используется с сокетами, ориентированными на устанавление соединения (SOCK_STREAM, SOCK_SEQPACKET и SOCK_RDM). Эта функция извлекает первый запрос на соединение из очереди ожидающих соединений, создаёт новый подключенный сокет почти с такими же параметрами, что и у s, 
и выделяет для сокета новый файловый дескриптор, который и возвращается. Новый сокет более не находится в слушающем состоянии. Исходный сокет s не изменяется при этом вызове. Заметим, что флаги файловых дескрипторов (те, что можно установить с помощью параметра F_SETFL функции fcntl, 
типа неблокированного состояния или асинхронного ввода-вывода) не наследуются новым файловым дескриптором после accept.
Аргумент s~-- это сокет, который был создан с помощью socket(2), привязан к локальному адресу с помощью bind(2), и слушает соединения после listen(2).

Аргумент addr~-- это указатель на структуру sockaddr. В эту структуру помещается адрес другой стороны, в том виде, в каком он известен на коммуникационном уровне. Точный формат адреса, передаваемого в параметре addr, определяется "семейством" сокета (см. socket(2) и страницу руководства по соответствующему протоколу). 
Аргумент addrlen является параметром, передаваемым по ссылке: перед вызовом он содержит размер структуры, на которую ссылается addr, а после вызова~-- действительную длину адреса в байтах. Если addr равен NULL, он не заполняется.
( Этот системный вызов возвращает -1 в случае ошибки.  При успешном завершении возвращается неотрицательное целое, являющееся дескриптором сокета.)

!!! recv, recvfrom, recvmsg - получить сообщение из сокета 
используются для получения сообщений из сокета, и могут использоваться для получения данных, независимо от того, является ли сокет ориентированным на соединения или нет.
Если параметр from не равен NULL, а сокет не является ориентированным на соединения, то адрес отправителя в сообщении не заполняется. Аргумент fromlen передается по ссылке, в начале инициализируется размером буфера, связанного с from, а при возврате из функции содержит действительный размер адреса. 
(Эти системные вызовы возвращают количество принятых байт или -1, если произошла ошибка)

!!! send, sendto, sendmsg - отправляет сообщения в сокет, используются для пересылки сообщений в другой сокет. send можно использовать, только если сокет находится в состоянии соединения, тогда как sendto и sendmsg можно использовать в любое время.
Адрес получателя задается параметром to длиной tolen. Длина сообщения задается параметром len. Если сообщение слишком длинное, чтобы быть отосланным протоколом нижнего уровня, возвращается ошибка EMSGSIZE, а сообщение не отсылается.
Неудачная отправка не показывается с помощью   send. Локальные ошибки принимают значение -1. (Эти системные вызовы возвращают количество отправленных символов или -1, если произошла ошибка)

!!! close (-udp) закрывает файловый дескриптор, который после этого не ссылается ни на один и файл и может быть использован повторно. Все блокировки, находящиеся на соответствующем файле, снимаются (независимо от того, был ли использован для установки блокировки именно этот файловый дескриптор).
Если fd является последней копией какого-либо файлового дескриптора, то ресурсы, связанные с ним, освобождаются; если дескриптор был последней ссылкой на файл, удаленный с помощью unlink(2), то файл окончательно удаляется. 
(close возвращает ноль при успешном завершении или -1, если произошла ошибка. )

!!! connect - инициирует соединение на сокете. Файловый дескриптор sockfd должен ссылаться на сокет. Если сокет имеет тип SOCK_DGRAM, значит, адрес serv_addr является адресом по умолчанию, куда посылаются датаграммы, и единственным адресом, откуда они принимаются. Если сокет имеет тип SOCK_STREAM или SOCK_SEQPACKET, 
то данный системный вызов попытается установить соединение с другим сокетом. Другой сокет задан параметром serv_addr, являющийся адресом длиной addrelen в пространстве коммуникации сокета. Каждое пространство коммуникации интерпретирует параметр serv_addr по-своему.
Обычно сокеты с протоколами, основанными на соединении, могут устанавливать соединение только один раз; сокеты с протоколами без соединения могут использовать connect многократно, чтобы изменить адрес назначения. Сокеты без поддержки соединения могут прекратить связь с другим сокетом, установив член sa_family структуры sockaddr в AF_UNSPEC.    
(Если соединение или привязка прошла успешно, возвращается нуль. При ошибке возвращается -1, а errno устанавливается должным образом.)

Задание: 

 make
gcc -o tcp_c tcpclient.c -I.
gcc -o tcp_s tcpserver.c -I.
gcc -o udp_c udpclient.c -I.
gcc -o udp_s udpserver.c -I.

TCP

1 вкладка: 
$ ./tcpserver --buf_size 100 --serv_port 10051
connection established

2 вкладка: 
$ ./tcpclient --bufsize 100 --serv 127.0.0.1 --port 10051
argc = 7
argv[1] = --bufsize
argv[2] = 100
argv[3] = --serv
argv[4] = 127.0.0.1
argv[5] = --port
argv[6] = 10051
Input message to send
fgjfhgjhghhjhhg
hgujkjhkjhhj

UDP

1 вкладка:
$ ./udpserver --port 10007 --bufsize 1024
SERVER starts...

2 вкладка:
$ ./udpclient --bufsize 100 --serv 127.0.0.1 --port 10007
argv[1] = --bufsize
argv[2] = 100
argv[3] = --serv
argv[4] = 127.0.0.1
argv[5] = --port
argv[6] = 10007
Enter string
hguyghjgkjhiu

Ответы на вопросы:

1. Что делают оба приложения?

tcp-версия отправляет на сервер сообщение, которое сервер выводит в консоль

udp-версия отправляет сообщение на сервер, сервер выводит его в консоль и отправляет этот же текст клиенту

2. Что произойдет, если tcpclient отправит сообщение незапущенному серверу?

Не установлено соединение. tcpclient не сможет отправить незапущенному.

3. Что произойдет, если udpclient отправит сообщение незапущенному серверу?

Клиент будет ждать ответ

4. Что произойдет, если tcpclient отвалится во время работы с сервером?

Сервер продолжит работу

5. Что произойдет, если udpclient отвалится во время работы с сервером?

Сервер продолжит работу

6. Что произойдет, если udpclient отправит сообщение на несуществующий / выключенный сервер?

Клиент будет ждать ответ

7. Что произойдет, если tcpclient отправит сообщение на несуществующий / выключенный сервер?

Не установлено соединение. tcpclient не сможет отправить несуществующему / выключенному серверу,

8. В чем отличия UDP и TCP протколов?

Расмотренно в предыдущих лабах (lab6)